<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8">
    <title>COVID Rapid-test Simulation</title>

    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, shrink-to-fit=no">
    <meta name="Referrer" content="origin">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="canonical" href="">
    <meta name="theme-color" content="#ffffff">

    <!-- <link rel="stylesheet" href="https://bootflat.github.io/bootflat/css/bootflat.css"> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
    <link rel="stylesheet" href="./styles.css" />

    <meta name="description" content="">
    <meta name="keywords" content="COVID,Rapid Testing">

    <!-- Facebook -->
    <meta property="og:app_id" content="">
    <meta property="og:title" content="">
    <meta property="og:description" content="">
    <meta property="og:url" content="">
    <meta property="og:image" content="">

    <!-- Twitter -->
    <meta name="twitter:card" content="">
    <meta name="twitter:site" content="">
    <meta name="twitter:title" content="">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="">

    <!-- LinkedIn -->
    <meta property="og:title" content="">
    <meta property="og:image" content="">
    <meta property="og:description" content="">
    <meta property="og:url" content="">

</head>
<body>
    <div class="container-md">
        <div class="block sm">
            <h1>Simulation testing.</h1>
            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
        </div>
        <div class="block">
            <!-- <canvas id="Simulation1" class="simulation"></canvas> -->
            <div id="Simulation1" class="simulation"></div>
        </div>
        <div class="block">
            <!-- Create a div where the graph will take place -->
            <canvas id="Simulation1Chart"></canvas>
        </div>
    </div>
</body>
<script defer src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js" type="text/javascript"></script>
<script defer src="https://d3js.org/d3.v3.js" type="text/javascript"></script>
<script src="./lib/simulation.js" type="text/javascript"></script>
<script>
    window.onload = function () {
        // set the dimensions and margins of the graph
        let margin = { top: 10, right: 30, bottom: 30, left: 50 };
        let width  = 460 - margin.left - margin.right;
        let height = 400 - margin.top - margin.bottom;
        
        // Add SVG element
        // const Chart = d3.select('#Simulation1Chart')
        //     .append('svg')
        //     .attr('width', width + margin.left + margin.right)
        //     .attr('height', height + margin.top + margin.bottom)
        //     .append('g')
        //     .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        
        // Process data events...
        // d3.csv("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered_comma.csv",
        
        //     // When reading the csv, I must format variables:
        //     function (d){
        //         return { date : d3.timeParse("%Y-%m-%d")(d.date), value : d.value }
        //     },
        
        // });

        // new Chart('Simulation1Chart', {
        //     type: 'line',
        //     data: {
        //         // labels: generateLabels(),
        //         datasets: [{
        //             backgroundColor: '#ddd', // utils.transparentize(presets.red),
        //             borderColor: '#ccc', // presets.red,
        //             data: [ 100, 110, 112], // generateData(),
        //             label: 'Dataset',
        //             fill: true
        //         }],
        //         // labels: ['January', 'February', 'March', 'April']
        //     },
        //     options: {
        //         maintainAspectRatio: false,
        //         spanGaps: false,
        //         elements: {
        //             line: {
        //                 tension: 0.000001
        //             }
        //         },
        //         plugins: {
        //             filler: {
        //                 propagate: false
        //             },
        //             title: {
        //                 // text: 'fill: ' + boundary,
        //                 display: true
        //             }
        //         },
        //         scales: {
        //             yAxes: [{
        //                 ticks: {
        //                     suggestedMin: 0,
        //                     suggestedMax: 100
        //                 }
        //             }],
        //             xAxes: [{
        //                 ticks: {
        //                     max: 1000,
        //                     min: 0,
        //                     stepSize: 10
        //                 }
        //             }]
        //         }
        //         // scales: {
        //         //     x: {
        //         //         ticks: {
        //         //             autoSkip: false,
        //         //             maxRotation: 0
        //         //         }
        //         //     }
        //         // }
        //     }
        // });

        // Add X axis --> it is a date format
        // let x = d3.scaleTime()
        //     .domain(d3.extent(data, function(d) { return d.date; }))
        //     .range([ 0, 100 ]);
        
        // svg.append("g")
        //     .attr("transform", "translate(0," + height + ")")
        //     .call(d3.axisBottom(x));
    
        // // Add Y axis
        // let y = d3.scaleLinear()
        //     .domain([0, d3.max(data, function(d) { return +d.value; })])
        //     .range([ height, 0 ]);
        // svg.append("g")
        //     .call(d3.axisLeft(y));

        // Now I can use this dataset:
        function processDataPoint(current) { 
            console.log("Count: ", current.tickCnt, " -- ",
                current.countof(ACTOR_STATUS.SUSCEPTIBLE),
                current.countof(ACTOR_STATUS.INFECTIOUS),
                current.countof(ACTOR_STATUS.RECOVERED),
                current.countof(ACTOR_STATUS.DECEASED),
            );       
            // Add the area
            // svg.append("path")
            //     .datum(data)
            //     .attr("fill", "#cce5df")
            //     .attr("stroke", "#69b3a2")
            //     .attr("stroke-width", 1.5)
            //     .attr("d", d3.area()
            //         .x(function(d) { return x(d.date) })
            //         .y0(y(0))
            //         .y1(function(d) { return y(d.value) })
            //     );

            // Update Charts.js chart
            // myChart.update({ duration: 0 });
        }

        console.log('Starting simulation...');
        const parameters = new SimulationParameters();
        console.log('Population size:', parameters.populationSize);
        const simulation = new Simulation(parameters);

        for (let t = 0; t < 1000; t++) {
            simulation.tick();
            processDataPoint(simulation);
            // simulation.update();
        }

        console.log("End Simulation");
    };
</script>

<!-- Animated Balls -->
<script>

    /** An enum containing the color scheme for the visualization. */
    const COLORS = {
        BLUE:    '#1070CA',
        TEAL:    '#14B5D0',
        YELLOW:  '#F7D154',
        ORANGE:  '#D9822B',
        RED:     '#EC4C47',
        GREEN:   '#47B881',
        NEUTRAL: '#425A70',
        DARK:    '#234361',
        LIGHT:   '#E4E7EB',

        // Neutral scale
        N1:  '#F9F9FB',
        N2:  '#F5F6F7',
        N3:  '#EDF0F2',
        N4:  '#E4E7EB',
        N5:  '#C7CED4',
        N6:  '#A6B1BB',
        N7:  '#7B8B9A',
        N8:  '#66788A',
        N9:  '#425A70',
        N10: '#234361'
    };

    /** Picks a random integer between `min` and `max`. */
    const between = (min = 0, max = 10) => Math.floor(Math.random() * (max - min) + min);

    window.onload = function() {
        /**
         * Ball object - multiple balls can be created by instantiating new objects
         */
        function Ball(svg, x, y, id, color, direction, radius) {
            this.posX      = x; // cx
            this.posY      = y; // cy
            this.color     = color;
            this.radius    = radius;
            this.speed     = 1.5;
            this.svg       = svg; // parent SVG
            this.id        = id; // id of ball
            this.direction = direction;
            this.weight    = radius;

            if (!this.direction) {
                this.direction = Math.PI / 7;
            }
            if (!this.weight) {
                this.weight = 10;
            }
            this.radius = this.weight;

            this.data = [this.id]; // allow us to use d3.enter()

            var self = this;

            // **** direction is used only here -- earlier I was using to next move position.
            // Now direction and speed together is velocity
            this.vx = Math.cos(self.direction) * self.speed;
            this.vy = Math.sin(self.direction) * self.speed;
            this.initialVx   = this.vx;
            this.initialVy   = this.vy;
            this.initialPosX = this.posX;
            this.initialPosY = this.posY;

            // when speed changes, go to initial setting
            this.GoToInitialSettings = function (newSpeed) {
                self.posX = self.initialPosX;
                self.posY = self.initialPosY;
                self.vx = Math.cos(self.direction) * newSpeed;
                self.vy = Math.sin(self.direction) * newSpeed;
                self.Draw();
            }

            this.Draw = function () {
                let svg = self.svg;
                let ball = svg
                    .selectAll('#' + self.id)
                    .data(self.data);

                ball.enter()
                    .append("circle")
                    .attr({"id" : self.id, 'class' : 'ball', 'r' : self.radius, 'weight' : self.weight})
                    .style("fill", self.color);

                ball.attr("cx", self.posX)
                    .attr("cy", self.posY);

                // Intersect ball is used to show collision effect - every ball has it's own intersect ball
                let intersectBall = ball
                    .enter()
                    .append('circle')
                    .attr({ 'id': self.id + '_intersect', 'class': 'intersectBall' });
            }

            this.Move = function () {
                let svg = self.svg;

                //self.posX += Math.cos(self.direction) * self.speed;
                //self.posY += Math.sin(self.direction) * self.speed;

                self.posX += self.vx;
                self.posY += self.vy;

                if (parseInt(svg.attr('width')) <= (self.posX + self.radius)) {
                    self.posX = parseInt(svg.attr('width')) - self.radius - 1;
                    self.direction = Math.PI - self.direction;
                    self.vx = -self.vx;
                }

                if (self.posX < self.radius) {
                    self.posX = self.radius+1;
                    self.direction = Math.PI - self.direction;
                    self.vx = -self.vx;
                }

                if (parseInt(svg.attr('height')) < (self.posY + self.radius)) {
                    self.posY = parseInt(svg.attr('height')) - self.radius - 1;
                    self.direction = 2 * Math.PI - self.direction;
                    self.vy = -self.vy;
                }

                if (self.posY < self.radius) {
                    self.posY = self.radius+1;
                    self.direction = 2 * Math.PI - self.direction;
                    self.vy = -self.vy;
                }

                // **** NOT USING direction except during initilization. Just left this for future reference ***** 
                if (self.direction > 2 * Math.PI) {
                    self.direction = self.direction - 2 * Math.PI;
                }
                if (self.direction < 0) {
                    self.direction = 2 * Math.PI + self.direction;
                }

                self.Draw();
            }
        }

        function CheckCollision(ball1, ball2) {
            let absx = Math.abs(parseFloat(ball2.posX) - parseFloat(ball1.posX));
            let absy = Math.abs(parseFloat(ball2.posY) - parseFloat(ball1.posY));

            // Find distance between two balls.
            let distance = Math.sqrt((absx * absx) + (absy * absy));
            // Check if distance is less than sum of two radius - if yes, collision!
            if (distance < (parseFloat(ball1.radius) + parseFloat(ball2.radius))) {
                return true;
            }
            return false;
        }

        let balls = []; // global array representing balls
        let color = 'blue'; // d3.scale.category20();

        // courtsey thanks to several internet sites for formulas
        // detect collision, find intersecting point and set new speed + direction for each ball based on weight (weight=radius).
        function ProcessCollision(ball1, ball2) {
            if (ball2 <= ball1) {
                return;
            }
            if (ball1 >= (balls.length-1) || ball2 >= balls.length) {
                return;
            }

            ball1 = balls[ball1];
            ball2 = balls[ball2];

            if (CheckCollision(ball1, ball2)) {
                // Intersection point
                let interx = ((ball1.posX * ball2.radius) + ball2.posX * ball1.radius)
                    / (ball1.radius + ball2.radius);
                let intery = ((ball1.posY * ball2.radius) + ball2.posY  * ball1.radius)
                    / (ball1.radius + ball2.radius);

                // Show collision effect for 500 miliseconds
                let intersectBall = svg.select(`#${ball1.id}_intersect`);
                intersectBall
                    .attr({ 'cx': interx, 'cy': intery, 'r': 5, 'fill': COLORS.NEUTRAL })
                    .transition()
                    .duration(500)
                    .attr('r', 0);

                // Calculate new velocity of each ball.
                let vx1 = (ball1.vx * (ball1.weight - ball2.weight)
                    + (2 * ball2.weight * ball2.vx )) / (ball1.weight + ball2.weight);
                let vy1 = (ball1.vy * (ball1.weight - ball2.weight)
                    + (2 * ball2.weight * ball2.vy)) / (ball1.weight + ball2.weight);
                let vx2 = (ball2.vx * (ball2.weight - ball1.weight)
                    + (2 * ball1.weight * ball1.vx)) / (ball1.weight + ball2.weight);
                let vy2 = (ball2.vy * (ball2.weight - ball1.weight)
                    + (2 * ball1.weight * ball1.vy)) / (ball1.weight + ball2.weight);

                // Set velocities for both balls
                ball1.vx = vx1;
                ball1.vy = vy1;
                ball2.vx = vx2;
                ball2.vy = vy2;

                // Ensure one ball is not inside others. distant apart till not colliding
                while (CheckCollision(ball1, ball2)) {
                    ball1.posX += ball1.vx;
                    ball1.posY += ball1.vy;

                    ball2.posX += ball2.vx;
                    ball2.posY += ball2.vy;
                }
                ball1.Draw();
                ball2.Draw();
            }
        }

        function Initialize(containerId) {
            let height   = document.getElementById(containerId).clientHeight;
            let width    = document.getElementById(containerId).clientWidth;
            gContainerId = containerId;
            gCanvasId    = containerId + '_canvas';
            gTopGroupId  = containerId + '_topGroup';

            let svg = d3
                .select(`#${containerId}`)
                .append("svg")
                .attr("id", gCanvasId)
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("id", gTopGroupId)
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none");

            for (let i = 0; i < 20; i++) {
                balls.push(new Ball(
                    svg,
                    between(40, 550),
                    between(40, 400),
                    `n${i}`,
                    COLORS.BLUE,
                    Math.PI / Math.floor(Math.random() * 10),
                    10
                ));
                // balls.push(new Ball(svg, 501, 101, `n${i}`, 'blue', Math.PI / Math.floor(Math.random() * 10), 15));
                // balls.push(new Ball(svg, 51,  31,  'n2', 'blue', Math.PI / 3,           15));
                // balls.push(new Ball(svg, 201, 201, 'n3', 'blue', Math.PI / 9,           15));
                // balls.push(new Ball(svg, 91,  31,  'n4', 'blue', Math.PI / 2,           15));
                // balls.push(new Ball(svg, 201, 21,  'n5', 'blue', Math.PI + Math.PI / 4, 15));
                // balls.push(new Ball(svg, 401, 41,  'n6', 'blue', Math.PI + Math.PI / 7, 15));
            }
            // balls.push(new Ball(svg, 501, 101, 'n1', COLORS.BLUE, Math.PI / Math.floor(Math.random() * 10), 10));
            // balls.push(new Ball(svg, 51,  31,  'n2', COLORS.BLUE, Math.PI / 3, 10));
            // balls.push(new Ball(svg, 201, 201, 'n3', COLORS.BLUE, Math.PI / 9, 10));
            // balls.push(new Ball(svg, 91,  31,  'n4', COLORS.BLUE, Math.PI / 2, 10));
            // balls.push(new Ball(svg, 201, 21,  'n5', COLORS.BLUE, Math.PI + Math.PI / 4, 10));
            // balls.push(new Ball(svg, 401, 41,  'n6', COLORS.BLUE, Math.PI + Math.PI / 7, 10));

            for (let i = 0; i < balls.length; ++i) {
                balls[i].Draw();
            }
            return svg;
        }

        let startStopFlag = null;

        function StartStopGame() {
            if (startStopFlag == null) {
                d3.timer(function () {
                    for (let i = 0; i < balls.length; ++i) {
                        let r = balls[i].Move();
                        for (let j = i + 1; j < balls.length; ++j) {
                            ProcessCollision(i, j);
                        }
                    }
                    if (startStopFlag == null) { return true; }
                    else { return false; }
                }, 500);
                startStopFlag = 1;
            } else {
                startStopFlag = null;
            }
        }

        // Handle ESC key
        d3.select('body')
            .on('keydown', function () {
                if (balls.length == 0) {
                    return;
                }
                console.log(d3.event);
                // if ESC key - toggle start stop
                if (d3.event.keyCode == 27) {
                    StartStopGame();
                }
            });

        const svg = Initialize('Simulation1');
        StartStopGame();
    };

</script>

</html>
